<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Colby Sparks</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
    integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
    integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
    integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
    integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <style>
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }
        .container-fluid {
            max-width: 1000px;
        }
        text {
            color: white
        }
        a.nav-link { opacity: 0.5; }
        a.nav-link:hover { opacity: 1; }

        a.btn:hover { background-color: black; color: white; }

        .bg {
            background-color: black;
        }

        .padding-top {
            padding-top: 40px;
        }
        h1 {
            font-weight: normal;
            font-style: normal;
            color: white;
            justify-content: center;
        }
        h2 {
            font-weight: normal;
            font-style: normal;
            color: white;
            justify-content: center;
        }
        h3 {
            color: white;
        }
        h4 {
            color: white;
        }
        p {
            color: white;
        }
        .nav a {
            font-weight: normal;
            font-style: normal;
            color: white;
        }
        .nav a:hover {
            color:grey;
        }
        .btn {
            background-color: hotpink;
        }
        .btn  {
            color: black;
        }
        #page-title {
            display: flex;
            justify-content: center;
            vertical-align: center;
            align-items: center;
        }
        #title-content {
            flex: 0 0 240px;
        }
        #front-page-filler {
            height: 100vh;
        }
        #projects-sub-section {
            display: flex;
            background-color: rgba(23, 23, 23, 0.447);
        }
        .video-container {
            position: relative;
            width: 80%; /* 80% of the parent container's width */
            height: 0; /* Height will be determined by the aspect ratio */
            padding-bottom: 45.0%;
            margin: 0 auto;
            text-align: center;
            overflow: hidden; /* Ensure the video doesn't overflow */
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .gallery {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: flex-start;
        }
        .nested-gallery {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-start;
        }
        .gallery-item-quarter {
            padding: 1%;
            flex-basis: calc(25% - 2%);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .gallery-item-half {
            padding: 1%;
            flex-basis: calc(50% - 2%);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .gallery-item-full {
            flex-basis: calc(100%);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .gallery-item-full img, .gallery-item-full video {
            width: 100%;
            height: auto;
            object-fit: cover;
        }
        .gallery-item-quarter img, .gallery-item-quarter video, .gallery-item-half img, .gallery-item-half video {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            object-fit: cover;
        }
        .gallery-caption {
            margin-top: 10px;
            color: lightslategrey;
            font-size: 16px;
            text-align: left;
        }
        .button-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .button-image {
            width: 75%;
            max-width: 500px;
            aspect-ratio: 3/2;
            display: inline-block;
            text-decoration: none;
            background-image: url('assets/repo-riot.png');
            background-size: cover;
            padding: 20px 30px;
            color: white;
            border-radius: 8px;
            text-align: center;
            transition: transform 0.3s ease;
        }
        .button-image:hover {
            transform: scale(1.05);
        }
        .project {
            text-align: center;
       </style>
</head>
<body>
<div class="container-fluid pt-3" id="top">
    <div class="row">
        <div class="col-sm-4 padding-top">
            <ul class="nav justify-content-center">
            <li class="nav-item">
                <a class="nav-link" href="#projects">projects</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#about">about</a>
            </li>
            </ul>
        </div>

        <div id="page-title" class="col-sm-4 padding-top">
            <div id="title-content"><h1>Colby Sparks</h1></div>
        </div>

        <div class="col-sm-4 padding-top">
            <ul class="nav justify-content-center">
                <li class="nav-item">
                    <a class="nav-link" href="https://www.github.com/cosparks">github</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#contact">contact</a>
                </li>
            </ul>
        </div>
    </div>

    <!-- FRONT PAGE FILLER -->
    <div id="front-page-filler"></div>

    <!-- PROJECTS -->
    <div class="container-fluid" id="projects">
        <h1>projects</h1>
        <br>
        <div class="container-fluid" style="background-color: rgba(12, 12, 12, 0.653);">
            <h2>Balloonium</h2>
            <p>
                Physics based game where you play as a balloon trying to escape a cave. This game got its start as a team project for UBC's CPSC 
                427 video game programming course. My team and I have since decided to continue working on the game and are aiming to release it 
                some time in early 2025.
            </p>
            <div class="gallery-item-full">
                <div class="video-container">
                    <iframe src="https://www.youtube.com/embed/lzcgCclYAKM" frameborder="0" allowfullscreen=""></iframe>
                </div>
            </div>
            <br>
            <h4>Procedural level generation and asset placement</h4>
            <p>Generate level gridmap using WFC</p>
            <div class="gallery">
                <div class="gallery-item-quarter">
                    <img src="assets/input-example.png" style="image-rendering: pixelated; image-rendering: crisp-edges;">
                </div>
                <div class="gallery-item-quarter">
                    <img src="assets/raw-gridmap.png" style="image-rendering: pixelated; image-rendering: crisp-edges;">
                </div>
                <div class="gallery-item-quarter">
                    <img src="assets/gridmap-data-pre.png">
                </div>
                <div class="gallery-item-quarter">
                    <img src="assets/gridmap-data-post.png">
                </div>
            </div>
            <p>Draw tunnels on level gridmap, then use marching squares to place level tiles (two different styles).</p>
            <div class="gallery">
                <div class="gallery-item-half">
                    <img src="assets/tiled-stone.png">
                </div>
                <div class="gallery-item-half">
                    <img src="assets/tiled-void.png">
                </div>
            </div>
            <p>Place assets: enemies, obstacles, resources and interaction zones; and add parallax background.</p>
            <div class="gallery">
                <div class="gallery-item-half">
                    <img src="assets/level-final-stone.png">
                </div>
                <div class="gallery-item-half">
                    <img src="assets/level-final-void.png">
                </div>
            </div>
            <br>
        </div>
        <br>
        <div class="container-fluid" style="background-color: rgba(23, 23, 23, 0.447);">
            <h2>repo riot</h2>
            <p>Global Game Jam 2024 submission. Game overview and playable demo available via the link below.</p>
            <div class="button-container">
                <a href="https://usualvirtue.itch.io/reporiot" class="button-image"></a>
            </div>
            <br>
        </div>
        <br>
        <div class="container-fluid" style="background-color: rgba(23, 23, 23, 0.447);">
            <h2>trypdeck</h2>
            <p>Interactive art installation</p>
            <div class="gallery">
                <div class="gallery-item-full">
                    <img src="assets/trypdeck.png">
                </div>
            </div>
            <br>
        </div>
    </div>
    <br>
    <!-- ABOUT -->
    <div class="container-fluid" style="min-height:100vh;" id="about">
        <h2>about</h2>
    </div>
    <div class="container-fluid" id="contact">
        <h2>contact</h2>
        <div class="container-fluid" style="min-height:50vh; background-color: rgba(0, 0, 0, 0.132);">
            
        </div>
    </div>
  </div>
  <canvas></canvas>
<!-- SHADERS -->
<script id="normalVertexShader" type="x-shader/x-vertex">
    precision highp float;
    
    out vec3 worldNormal;
    out vec3 vcsNormal;
    out vec3 vcsPosition;

    uniform float time;

    void main()
    {
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        vcsPosition = mvPosition.xyz;
        vcsNormal = normalMatrix * normal;
        worldNormal = normal;
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="fractalVertexShader" type="x-shader/x-vertex">
    precision highp float;

    out vec3 vcsNormal;
    out vec3 vcsPosition;

    uniform float time;
    
    const float speed = 2.0;
    const float heightOffset = 0.1;

    void main()
    {
        float dist = sqrt(pow(position.x, 2.0) + pow(position.z, 2.0));
        float timeVal1 = time * speed;
        float sinValY = sin(timeVal1 + dist);
        vec3 pos = vec3(position.x, position.y + sinValY * heightOffset, position.z);
        
        vcsPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;

        // compute varying normal
        float partialCos = heightOffset * cos(timeVal1 + dist);
        vec3 tangent = vec3(0, partialCos * position.z / dist, 1);
        vec3 binormal = vec3(1, partialCos * position.x / dist, 0);
        vcsNormal = normalMatrix * normalize(cross(tangent, binormal));
        
        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="waterVertexShader" type="x-shader/x-vertex">
    precision highp float;

    out vec3 vcsNormal;
    out vec3 vcsPosition;
    out vec3 worldPosition;

    uniform float time;
    uniform int numWaves;
    uniform vec2 waveDirections[50];

    const float a0 = 5.0;
    const float w0 = 2.0 / 100.0 * 3.14;
    const float phi = 20.0 * w0;

    // const float amplitudeFactor = 0.7;
    const float amplitudeFactor = 0.6;
    const float frequencyFactor = 1.3;

    void main()
    {
        float posY = position.y;
        float partialX = 0.0;
        float partialZ = 0.0;
        float ai = a0;
        float wi = w0;
        float phii = phi;
        float prevPartialX = 0.0;
        float prevPartialZ = 0.0;
        vec3 pushedPos = position;
        
        int iterations = min(numWaves, 50);
        for (int i = 0; i < iterations; i++) {
            // pushedPos += vec3(prevPartialX, 0.0, prevPartialZ);
            vec2 di = normalize(waveDirections[i]);
            // posY += ai * sin(wi * dot(di, pushedPos.xz)  + time * phii );
            float curY = ai * exp(sin(wi * dot(di, pushedPos.xz) + time * phii) - 1.0);
            posY += curY;

            // compute normal                  
            prevPartialX = wi * di.x * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
            prevPartialZ = wi * di.y * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
            partialX += prevPartialX;
            partialZ += prevPartialZ;

            ai *= amplitudeFactor;
            wi *= frequencyFactor;
            phii *= 1.05;
        }
        
        vec3 pos = vec3(position.x, posY, position.z);
        vcsPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;
        vec3 tangent = vec3(0, partialZ, 1);
        vec3 binormal = vec3(1, partialX, 0);
        vcsNormal = normalMatrix * normalize(cross(tangent, binormal));
        worldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="waterFragmentShader" type="x-shader/x-fragment">
    in vec3 vcsNormal;
    in vec3 vcsPosition;
    in vec3 worldPosition;

    uniform float time;
    uniform vec3 vcsPositionSun;
    uniform vec3 sunColour;
    uniform vec3 vcsPositionStar1;
    uniform vec3 colourStar1;
    uniform vec3 vcsPositionStar2;
    uniform vec3 colourStar2;
    uniform vec3 vcsPositionStar3;
    uniform vec3 colourStar3;
    uniform vec3 waterColour;
    uniform vec3 ambientColour;
    uniform vec3 diffuseColour;
    
    // skybox
    uniform sampler2D uPosxTexture;
    uniform sampler2D uPosyTexture;
    uniform sampler2D uPoszTexture;
    uniform sampler2D uNegxTexture;
    uniform sampler2D uNegyTexture;
    uniform sampler2D uNegzTexture;
    uniform mat4 inverseViewMatrix;
    uniform float skyboxSize;
    uniform float skyboxOffsetY;

    // const float sunDiffuseAmt = 0.5;
    // const float sunSpecularAmt = 0.8;
    // const float starDiffuseAmt = 0.1;
    // const float starSpecularAmt = 0.4;

    const float sunDiffuseAmt = 0.0;
    const float sunSpecularAmt = 0.4;
    const float starDiffuseAmt = 0.0;
    const float starSpecularAmt = 0.2;

    const float specular = 200.0;
    const vec4 nullVec = vec4(0,0,0,-1);

    vec3 applyLightSource(vec3 vcsPos, vec3 N, vec3 lightColour, float diffuseAmt, float specularAmt) {
        // diffuse component
        vec3 L = normalize(vcsPos - vcsPosition);
        vec3 colour = diffuseAmt * waterColour * lightColour * max(0.0, dot(N, L));
        
        // specular component
        vec3 V = normalize(-vcsPosition.xyz);
        vec3 R = reflect(-L, N);
        return colour + specularAmt * lightColour * pow(max(0.0, dot(V,R)), specular);
    }

    vec4 getSkyboxIntersection(vec4 R, vec4 wcsPos, vec3 wallN, vec3 wallPos) {
        float dotWall = dot(wallN, R.xyz);
        if (dotWall == 0.0) {
            // reflection is orthogonal to wall normal -> no intersection
            return nullVec;
        }
        
        // find point at which 
        float tFront = (dot(wallN, wallPos) - dot(wallN, wcsPos.xyz)) / dotWall;
        if (tFront < 0.0) {
            return nullVec;
        }
        return vec4((wcsPos + tFront * R).xyz, 1.0);
    }

    vec4 lookupSkyboxTexel(vec3 N) {
        vec3 I = normalize(vcsPosition);
        vec3 vcsR = reflect(I, N);
        vec4 R = inverseViewMatrix * vec4(vcsR, 0.0);
        vec4 wcsPosition = inverseViewMatrix * vec4(vcsPosition, 1.0);
        vec4 ret = vec4(0, 0, 0, 1.0);

        // check front intersection
        vec4 intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,0,1), vec3(0,0,-skyboxSize));
        float u = (intersection.x / skyboxSize + 1.0) / 2.0;
        float v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uNegzTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check top intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,-1,0), vec3(0, 2.0 * skyboxSize + skyboxOffsetY, 0));
        u = (intersection.x / skyboxSize + 1.0) / 2.0;
        v = (intersection.z / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPosyTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check right intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(-1,0,0), vec3(skyboxSize, 0, 0));
        u = (intersection.z / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPosxTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check left intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(1,0,0), vec3(-skyboxSize, 0, 0));
        u = 1.0 - (intersection.z / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uNegxTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check back intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,0,-1), vec3(0, 0, skyboxSize));
        u = 1.0 - (intersection.x / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPoszTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        return ret;
    }

    void main() {
        // base ambient component
        // vec3 color = waterColour * ambientColour * 0.1;
        vec3 color = vec3(0);
        vec3 N = normalize(vcsNormal);
        
        vec4 texel = lookupSkyboxTexel(N);
        color += texel.xyz;

        // apply diffuse and specular for all light sources
        color += applyLightSource(vcsPositionSun, N, sunColour, sunDiffuseAmt, sunSpecularAmt);
        color += applyLightSource(vcsPositionStar1, N, colourStar1, starDiffuseAmt, starSpecularAmt);
        color += applyLightSource(vcsPositionStar2, N, colourStar2, starDiffuseAmt, starSpecularAmt);
        color += applyLightSource(vcsPositionStar3, N, colourStar3, starDiffuseAmt, starSpecularAmt);

        gl_FragColor = vec4(color, 1.0);
        // gl_FragColor = texel;
    }
</script>
<script id="postVertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="postFragmentShader" type="x-shader/x-fragment">
    #include <packing>

    varying vec2 vUv;

    uniform sampler2D tDiffuse;
    uniform sampler2D tDepth;
    uniform mat4 inverseProjectionMatrix;
    uniform mat4 inverseViewMatrix;
    uniform float aspectRatio;
    uniform float cameraNear;
    uniform float cameraFar;

    // lights
    uniform vec3 sunPosUv;
    uniform vec3 sunColour;
    uniform float sunFocus;
    uniform vec3 uvPosStar1;
    uniform vec3 colourStar1;
    uniform float focusStar1;
    uniform vec3 uvPosStar2;
    uniform vec3 colourStar2;
    uniform float focusStar2;
    uniform vec3 uvPosStar3;
    uniform vec3 colourStar3;
    uniform float focusStar3;
    uniform vec4 fogColour;
    uniform float fogDensity;
    
    const float sunWidth = 0.02;
    const float starWidth = 0.0;

    vec4 applyLight(vec2 uvPosLight, float focus, vec3 lightColour, vec4 color, float lightWidth) {
        vec2 scaledVec = vec2((vUv.x - uvPosLight.x) / aspectRatio, (vUv.y - uvPosLight.y));
        float dist = length(scaledVec);
        float lightFactor = 1.0 / pow(2.0, (dist - lightWidth) * focus * focus);
        return mix(color, vec4(lightColour, 1.0), lightFactor);
    }

    void main() {
        //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
        float fragCoordZ = texture2D( tDepth, vUv ).x;
        float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
        float depth = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

        vec4 color = texture2D(tDiffuse, vUv);
        
        // get world-space y coordinates of current pixel
        // vec4 ccsPos = vec4(vUv * 2.0 - 1.0, -cameraNear, 1.0) * (-viewZ / cameraNear);
        // vec4 worldPos = inverseProjectionMatrix * ccsPos;
        
        float fogFactor = 1.0 - 1.0 / pow(2.0, (depth * fogDensity) * (depth * fogDensity));
        color = mix(color, fogColour, fogFactor);

        // check if sun or star is blocked by waves
        if (fragCoordZ > uvPosStar1.z) {
            color = applyLight(uvPosStar1.xy, focusStar1, colourStar1, color, starWidth);
        }
        if (fragCoordZ > uvPosStar2.z) {
            color = applyLight(uvPosStar2.xy, focusStar2, colourStar2, color, starWidth);
        }
        if (fragCoordZ > uvPosStar3.z) {
            color = applyLight(uvPosStar3.xy, focusStar3, colourStar3, color, starWidth);
        }
        if (fragCoordZ > sunPosUv.z) {
            color = applyLight(sunPosUv.xy, sunFocus, sunColour, color, sunWidth);
        }
        gl_FragColor = color;
    }
</script>
</body>
</html>
