<html>
<head></head>
<body>
<script id="normalVertexShader" type="x-shader/x-vertex">
    precision highp float;
    
    out vec3 worldNormal;
    out vec3 vcsNormal;
    out vec3 vcsPosition;

    uniform float time;

    void main()
    {
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        vcsPosition = mvPosition.xyz;
        vcsNormal = normalMatrix * normal;
        worldNormal = normal;
        gl_Position = projectionMatrix * mvPosition;
    }
</script>
<script id="fractalVertexShader" type="x-shader/x-vertex">
    precision highp float;

    out vec3 vcsNormal;
    out vec3 vcsPosition;

    uniform float time;
    
    const float speed = 2.0;
    const float heightOffset = 0.1;

    void main()
    {
        float dist = sqrt(pow(position.x, 2.0) + pow(position.z, 2.0));
        float timeVal1 = time * speed;
        float sinValY = sin(timeVal1 + dist);
        vec3 pos = vec3(position.x, position.y + sinValY * heightOffset, position.z);
        
        vcsPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;

        // compute varying normal
        float partialCos = heightOffset * cos(timeVal1 + dist);
        vec3 tangent = vec3(0, partialCos * position.z / dist, 1);
        vec3 binormal = vec3(1, partialCos * position.x / dist, 0);
        vcsNormal = normalMatrix * normalize(cross(tangent, binormal));
        
        vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="waterVertexShader" type="x-shader/x-vertex">
    precision highp float;

    out vec3 vcsNormal;
    out vec3 vcsPosition;
    out vec3 worldPosition;

    uniform float time;
    uniform int numWaves;
    uniform vec2 waveDirections[50];

    const float a0 = 5.0;
    const float w0 = 2.0 / 100.0 * 3.14;
    const float phi = 20.0 * w0;

    // const float amplitudeFactor = 0.7;
    const float amplitudeFactor = 0.6;
    const float frequencyFactor = 1.3;

    void main()
    {
        float posY = position.y;
        float partialX = 0.0;
        float partialZ = 0.0;
        float ai = a0;
        float wi = w0;
        float phii = phi;
        float prevPartialX = 0.0;
        float prevPartialZ = 0.0;
        vec3 pushedPos = position;
        
        int iterations = min(numWaves, 50);
        for (int i = 0; i < iterations; i++) {
            // pushedPos += vec3(prevPartialX, 0.0, prevPartialZ);
            vec2 di = normalize(waveDirections[i]);
            // posY += ai * sin(wi * dot(di, pushedPos.xz)  + time * phii );
            float curY = ai * exp(sin(wi * dot(di, pushedPos.xz) + time * phii) - 1.0);
            posY += curY;

            // compute normal                  
            prevPartialX = wi * di.x * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
            prevPartialZ = wi * di.y * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
            partialX += prevPartialX;
            partialZ += prevPartialZ;

            ai *= amplitudeFactor;
            wi *= frequencyFactor;
            phii *= 1.05;
        }
        
        vec3 pos = vec3(position.x, posY, position.z);
        vcsPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;
        vec3 tangent = vec3(0, partialZ, 1);
        vec3 binormal = vec3(1, partialX, 0);
        vcsNormal = normalMatrix * normalize(cross(tangent, binormal));
        worldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
        
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script id="waterFragmentShader" type="x-shader/x-fragment">
    in vec3 vcsNormal;
    in vec3 vcsPosition;
    in vec3 worldPosition;

    uniform float time;
    uniform vec3 vcsPositionSun;
    uniform vec3 sunColour;
    uniform vec3 vcsPositionStar1;
    uniform vec3 colourStar1;
    uniform vec3 vcsPositionStar2;
    uniform vec3 colourStar2;
    uniform vec3 vcsPositionStar3;
    uniform vec3 colourStar3;
    uniform vec3 waterColour;
    uniform vec3 ambientColour;
    uniform vec3 diffuseColour;
    
    // skybox
    uniform sampler2D uPosxTexture;
    uniform sampler2D uPosyTexture;
    uniform sampler2D uPoszTexture;
    uniform sampler2D uNegxTexture;
    uniform sampler2D uNegyTexture;
    uniform sampler2D uNegzTexture;
    uniform mat4 inverseViewMatrix;
    uniform float skyboxSize;
    uniform float skyboxOffsetY;

    // const float sunDiffuseAmt = 0.5;
    // const float sunSpecularAmt = 0.8;
    // const float starDiffuseAmt = 0.1;
    // const float starSpecularAmt = 0.4;

    const float sunDiffuseAmt = 0.0;
    const float sunSpecularAmt = 0.4;
    const float starDiffuseAmt = 0.0;
    const float starSpecularAmt = 0.2;

    const float specular = 200.0;
    const vec4 nullVec = vec4(0,0,0,-1);

    vec3 applyLightSource(vec3 vcsPos, vec3 N, vec3 lightColour, float diffuseAmt, float specularAmt) {
        // diffuse component
        vec3 L = normalize(vcsPos - vcsPosition);
        vec3 colour = diffuseAmt * waterColour * lightColour * max(0.0, dot(N, L));
        
        // specular component
        vec3 V = normalize(-vcsPosition.xyz);
        vec3 R = reflect(-L, N);
        return colour + specularAmt * lightColour * pow(max(0.0, dot(V,R)), specular);
    }

    vec4 getSkyboxIntersection(vec4 R, vec4 wcsPos, vec3 wallN, vec3 wallPos) {
        float dotWall = dot(wallN, R.xyz);
        if (dotWall == 0.0) {
            // reflection is orthogonal to wall normal -> no intersection
            return nullVec;
        }
        
        // find point at which 
        float tFront = (dot(wallN, wallPos) - dot(wallN, wcsPos.xyz)) / dotWall;
        if (tFront < 0.0) {
            return nullVec;
        }
        return vec4((wcsPos + tFront * R).xyz, 1.0);
    }

    vec4 lookupSkyboxTexel(vec3 N) {
        vec3 I = normalize(vcsPosition);
        vec3 vcsR = reflect(I, N);
        vec4 R = inverseViewMatrix * vec4(vcsR, 0.0);
        vec4 wcsPosition = inverseViewMatrix * vec4(vcsPosition, 1.0);
        vec4 ret = vec4(0, 0, 0, 1.0);

        // check front intersection
        vec4 intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,0,1), vec3(0,0,-skyboxSize));
        float u = (intersection.x / skyboxSize + 1.0) / 2.0;
        float v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uNegzTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check top intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,-1,0), vec3(0, 2.0 * skyboxSize + skyboxOffsetY, 0));
        u = (intersection.x / skyboxSize + 1.0) / 2.0;
        v = (intersection.z / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPosyTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check right intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(-1,0,0), vec3(skyboxSize, 0, 0));
        u = (intersection.z / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPosxTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check left intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(1,0,0), vec3(-skyboxSize, 0, 0));
        u = 1.0 - (intersection.z / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uNegxTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        // check back intersection
        intersection = getSkyboxIntersection(R, wcsPosition, vec3(0,0,-1), vec3(0, 0, skyboxSize));
        u = 1.0 - (intersection.x / skyboxSize + 1.0) / 2.0;
        v = ((intersection.y - skyboxSize - skyboxOffsetY) / skyboxSize + 1.0) / 2.0;
        if (intersection != nullVec && u >= 0.0 && u <= 1.0 && v >= 0.0 && v <= 1.0) {
            vec3 colour = texture2D(uPoszTexture, vec2(u,v)).xyz;
            return vec4(colour, 1.0);
        }
        return ret;
    }

    void main() {
        // base ambient component
        // vec3 color = waterColour * ambientColour * 0.1;
        vec3 color = vec3(0);
        vec3 N = normalize(vcsNormal);
        
        vec4 texel = lookupSkyboxTexel(N);
        color += texel.xyz;

        // apply diffuse and specular for all light sources
        color += applyLightSource(vcsPositionSun, N, sunColour, sunDiffuseAmt, sunSpecularAmt);
        color += applyLightSource(vcsPositionStar1, N, colourStar1, starDiffuseAmt, starSpecularAmt);
        color += applyLightSource(vcsPositionStar2, N, colourStar2, starDiffuseAmt, starSpecularAmt);
        color += applyLightSource(vcsPositionStar3, N, colourStar3, starDiffuseAmt, starSpecularAmt);

        gl_FragColor = vec4(color, 1.0);
        // gl_FragColor = texel;
    }
</script>
<script id="postVertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;

    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="postFragmentShader" type="x-shader/x-fragment">
    #include <packing>

    varying vec2 vUv;

    uniform sampler2D tDiffuse;
    uniform sampler2D tDepth;
    uniform mat4 inverseProjectionMatrix;
    uniform mat4 inverseViewMatrix;
    uniform float aspectRatio;
    uniform float cameraNear;
    uniform float cameraFar;

    // lights
    uniform vec3 sunPosUv;
    uniform vec3 sunColour;
    uniform float sunFocus;
    uniform vec3 uvPosStar1;
    uniform vec3 colourStar1;
    uniform float focusStar1;
    uniform vec3 uvPosStar2;
    uniform vec3 colourStar2;
    uniform float focusStar2;
    uniform vec3 uvPosStar3;
    uniform vec3 colourStar3;
    uniform float focusStar3;
    uniform vec4 fogColour;
    uniform float fogDensity;
    
    const float sunWidth = 0.02;
    const float starWidth = 0.0;

    vec4 applyLight(vec2 uvPosLight, float focus, vec3 lightColour, vec4 color, float lightWidth) {
        vec2 scaledVec = vec2((vUv.x - uvPosLight.x) / aspectRatio, (vUv.y - uvPosLight.y));
        float dist = length(scaledVec);
        float lightFactor = 1.0 / pow(2.0, (dist - lightWidth) * focus * focus);
        return mix(color, vec4(lightColour, 1.0), lightFactor);
    }

    void main() {
        //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
        float fragCoordZ = texture2D( tDepth, vUv ).x;
        float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
        float depth = viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

        vec4 color = texture2D(tDiffuse, vUv);
        
        // get world-space y coordinates of current pixel
        // vec4 ccsPos = vec4(vUv * 2.0 - 1.0, -cameraNear, 1.0) * (-viewZ / cameraNear);
        // vec4 worldPos = inverseProjectionMatrix * ccsPos;
        
        float fogFactor = 1.0 - 1.0 / pow(2.0, (depth * fogDensity) * (depth * fogDensity));
        color = mix(color, fogColour, fogFactor);

        // check if sun or star is blocked by waves
        if (fragCoordZ > uvPosStar1.z) {
            color = applyLight(uvPosStar1.xy, focusStar1, colourStar1, color, starWidth);
        }
        if (fragCoordZ > uvPosStar2.z) {
            color = applyLight(uvPosStar2.xy, focusStar2, colourStar2, color, starWidth);
        }
        if (fragCoordZ > uvPosStar3.z) {
            color = applyLight(uvPosStar3.xy, focusStar3, colourStar3, color, starWidth);
        }
        if (fragCoordZ > sunPosUv.z) {
            color = applyLight(sunPosUv.xy, sunFocus, sunColour, color, sunWidth);
        }
        gl_FragColor = color;
    }
</script>
</body>
</html>