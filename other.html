<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - Depth Texture</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			#error {
				margin: auto;
				margin-top: 40px;
				display: block;
				max-width: 400px;
				padding: 20px;
				background: #CE0808;
			}
		</style>

		<script id="post-vert" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
        <script id="waterVertexShader" type="x-shader/x-vertex">
            precision highp float;

            out vec3 vcsNormal;
            out vec3 vcsPosition;
            out vec3 worldPosition;

            uniform float time;
            uniform int numWaves;
            uniform vec2 waveDirections[50];

            const float a0 = 10.0;
            const float w0 = 2.0 / 100.0 * 3.14;
            const float phi = 20.0 * w0;

            const float amplitudeFactor = 0.65;
            const float frequencyFactor = 1.3;

            void main()
            {
                float posY = position.y;
                float partialX = 0.0;
                float partialZ = 0.0;
                float ai = a0;
                float wi = w0;
                float phii = phi;
                float prevPartialX = 0.0;
                float prevPartialZ = 0.0;
                vec3 pushedPos = position;
                
                int iterations = min(numWaves, 50);
                for (int i = 0; i < iterations; i++) {
                    // pushedPos += vec3(prevPartialX, 0.0, prevPartialZ);
                    vec2 di = normalize(waveDirections[i]);
                    // posY += ai * sin(wi * dot(di, pushedPos.xz)  + time * phii );
                    float curY = ai * exp(sin(wi * dot(di, pushedPos.xz) + time * phii) - 1.0);
                    posY += curY;
    
                    // compute varying normal                    
                    prevPartialX = wi * di.x * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
                    prevPartialZ = wi * di.y * curY * cos(wi * dot(di, pushedPos.xz) + time * phii);
                    partialX += prevPartialX;
                    partialZ += prevPartialZ;

                    ai *= amplitudeFactor;
                    wi *= frequencyFactor;
                    phii *= 1.05;
                }
                
                vec3 pos = vec3(position.x, posY, position.z);
                vcsPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;
                vec3 tangent = vec3(0, partialZ, 1);
                vec3 binormal = vec3(1, partialX, 0);
                vcsNormal = normalMatrix * normalize(cross(tangent, binormal));
                worldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        </script>

        <script id="waterFragmentShader" type="x-shader/x-fragment">
            in vec3 vcsNormal;
            in vec3 vcsPosition;
            in vec3 worldPosition;

            uniform float time;
            uniform vec3 vcsPositionLight1;

            const vec3 ambientColor = vec3(0.0, 0.0, 1.0);
            const vec3 diffuseColor = vec3(0.0, 1.0, 0.0);
            const vec3 specularColor = vec3(1.0, 0, 0);
            const float specular = 250.0;

            const float maxVisibleDistance = 500.0;
            const float fogDensity = 0.005;
            const vec3 fogColour = vec3(0.0, 0.025, 0.025);

            void main() {

                // ambient component
                vec3 color = ambientColor * 0.5;
                
                // diffuse component
                vec3 N = normalize(vcsNormal);
                vec3 L = normalize(vcsPositionLight1 - vcsPosition);
                color = color + 0.5 * diffuseColor * max(0.0, dot(N, L));
                
                gl_FragColor = vec4(color, 1.0); // default fragment color
            }
        </script>
		<script id="post-frag" type="x-shader/x-fragment">
			#include <packing>

			varying vec2 vUv;
			uniform sampler2D tDiffuse;
			uniform sampler2D tDepth;
			uniform float cameraNear;
			uniform float cameraFar;


			float readDepth( sampler2D depthSampler, vec2 coord ) {
				float fragCoordZ = texture2D( depthSampler, coord ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
			}

			void main() {
				//vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
				float depth = readDepth( tDepth, vUv );

				gl_FragColor.rgb = 1.0 - vec3( depth );
				gl_FragColor.a = 1.0;
			}
		</script>

	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">threejs</a> webgl - depth texture<br/>
			Stores render target depth in a texture attachment.<br/>
			Created by <a href="http://twitter.com/mattdesl" target="_blank" rel="noopener">@mattdesl</a>.

			<div id="error" style="display: none;">
			Your browser does not support <strong>WEBGL_depth_texture</strong>.<br/><br/>
			This demo will not work.
			</div>
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import { randFloat } from 'three/src/math/MathUtils';

			let camera, scene, renderer, controls, stats;
			let target;
			let postScene, postCamera, postMaterial;
			let supportsExtension = true;
            let waterMaterial;
            
            const clock = new THREE.Clock();
            var time = 0.0;

			const params = {
				format: THREE.DepthFormat,
				type: THREE.UnsignedShortType
			};

			const formats = { DepthFormat: THREE.DepthFormat, DepthStencilFormat: THREE.DepthStencilFormat };
			const types = { UnsignedShortType: THREE.UnsignedShortType, UnsignedIntType: THREE.UnsignedIntType, UnsignedInt248Type: THREE.UnsignedInt248Type };
            const size = 750;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer();

				if ( renderer.capabilities.isWebGL2 === false && renderer.extensions.has( 'WEBGL_depth_texture' ) === false ) {

					supportsExtension = false;
					document.querySelector( '#error' ).style.display = 'block';
					return;

				}

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				stats = new Stats();
				document.body.appendChild( stats.dom );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 1000 );
				camera.position.set(150, 30, 500);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;

				// Create a render target with depth texture
				setupRenderTarget();

				// Our scene
				setupScene();

				// Setup post-processing step
				setupPost();

				onWindowResize();
				window.addEventListener( 'resize', onWindowResize );

				//
				const gui = new GUI( { width: 300 } );

				gui.add( params, 'format', formats ).onChange( setupRenderTarget );
				gui.add( params, 'type', types ).onChange( setupRenderTarget );
				gui.open();

			}

			function setupRenderTarget() {

				if ( target ) target.dispose();

				const format = parseFloat( params.format );
				const type = parseFloat( params.type );

				target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
				target.texture.minFilter = THREE.NearestFilter;
				target.texture.magFilter = THREE.NearestFilter;
				target.stencilBuffer = ( format === THREE.DepthStencilFormat ) ? true : false;
				target.depthTexture = new THREE.DepthTexture();
				target.depthTexture.format = format;
				target.depthTexture.type = THREE.UnsignedIntType;
			}

			function setupPost() {
				// Setup post processing stage
				postCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
				postMaterial = new THREE.ShaderMaterial( {
					vertexShader: document.querySelector( '#post-vert' ).textContent.trim(),
					fragmentShader: document.querySelector( '#post-frag' ).textContent.trim(),
					uniforms: {
						cameraNear: { value: camera.near },
						cameraFar: { value: camera.far },
						tDiffuse: { value: null },
						tDepth: { value: null }
					}
				} );
				const postPlane = new THREE.PlaneGeometry( 2, 2 );
				const postQuad = new THREE.Mesh( postPlane, postMaterial );
				postScene = new THREE.Scene();
				postScene.add( postQuad );

			}

			function setupScene() {

				scene = new THREE.Scene();

				const geometry = new THREE.TorusKnotGeometry( 1, 0.3, 128, 64 );
				const material = new THREE.MeshBasicMaterial( { color: 'blue' } );

				const count = 50;
				const scale = 5;

				for ( let i = 0; i < count; i ++ ) {

					const r = Math.random() * 2.0 * Math.PI;
					const z = ( Math.random() * 2.0 ) - 1.0;
					const zScale = Math.sqrt( 1.0 - z * z ) * scale;

					const mesh = new THREE.Mesh( geometry, material );
					mesh.position.set(
						Math.cos( r ) * zScale,
						Math.sin( r ) * zScale,
						z * scale
					);
					mesh.rotation.set( Math.random(), Math.random(), Math.random() );
					scene.add( mesh );
				}

                const color_light1 = new THREE.Color(1.0, 1.0, 1.0);
                var light1 = new THREE.PointLight( color_light1, 1, 100 );
                light1.position.set( 50, 150, -size+10);
                scene.add( light1 );

                var lightGeometry = new THREE.SphereGeometry(3, 10, 10);
                lightGeometry.computeVertexNormals();
                var lightMaterial = new THREE.MeshBasicMaterial();
                lightMaterial.color = new THREE.Color(1.0, 0.0, 0.0);
                var lightObject = new THREE.Mesh( lightGeometry, lightMaterial );
                lightObject.position.set(50, 100, -size+10);
                scene.add(lightObject);

                var vcsPositionLight1 = new THREE.Vector3(lightObject.position);
                vcsPositionLight1.set(lightObject.position.x, lightObject.position.y, lightObject.position.z);
                vcsPositionLight1.applyMatrix4(camera.matrixWorldInverse);
                
                const numWaves = 32;
                var floatArray = new Float32Array(numWaves * 2);
                for (var i = 0; i < numWaves; i++) {
                    floatArray[i * 2] = randFloat(-1.0, 1.0);
                    floatArray[i * 2 + 1] = randFloat(-1.0, 1.0);
                }


                waterMaterial = new THREE.ShaderMaterial( {
                    uniforms: {
                        time: { value: time },
                        vcsPositionLight1: { value: vcsPositionLight1 },
                        lightColor: { value: color_light1 },
                        numWaves: { value: numWaves },
                        waveDirections: { value: floatArray }
                    },
                        vertexShader: document.getElementById( 'waterVertexShader' ).textContent,
                        fragmentShader: document.getElementById( 'waterFragmentShader' ).textContent
                } );

                //////////////////////////////////////////////////////////////////////
                // objects

                var yCenter = -200;

                var waterGeometry = new THREE.PlaneGeometry(1000, 1000, 1000, 1000);
                waterGeometry.rotateX(-Math.PI / 2.0)
                waterGeometry.computeVertexNormals();
                var waterObject = new THREE.Mesh( waterGeometry, waterMaterial );
                waterObject.position.set(0, 0, 0);
                scene.add(waterObject);
			}

			function onWindowResize() {

				const aspect = window.innerWidth / window.innerHeight;
				camera.aspect = aspect;
				camera.updateProjectionMatrix();

				const dpr = renderer.getPixelRatio();
				target.setSize( window.innerWidth * dpr, window.innerHeight * dpr );
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				if ( ! supportsExtension ) return;

				requestAnimationFrame( animate );

                time = clock.getElapsedTime();
                waterMaterial.uniforms.time.value = time;

				// render scene into target
				renderer.setRenderTarget( target );
				renderer.render( scene, camera );

				// render post FX
				postMaterial.uniforms.tDiffuse.value = target.texture;
				postMaterial.uniforms.tDepth.value = target.depthTexture;

				renderer.setRenderTarget( null );
				renderer.render( postScene, postCamera );

				controls.update(); // required because damping is enabled

				stats.update();

			}

		</script>

	</body>
</html>